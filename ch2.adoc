= Chapter 2: Kubernetes basics 
:toc: manual
:toc-placement: preamble
:source-highlighter: pygments
:source-highlighter: coderay
:source-highlighter: prettify
:highlightjs-theme: googlecode
:coderay-linenums-mode: table
:coderay-linenums-mode: inline

This chapter introduces kubernetes, what is it, the basic terminologies and key
concepts of it. You will learn most of the commonly used and mentioned
components in kubernetes architecture. This chapter also provides an example to
launch a "minimal", but relatively complete kubernetes environment to
demonstrate how to interact with kubernetes in practice and how the virtual
environment orchestrated by kubernetes looks like.

== What is Kubernetes 

This is the description from the main page of official kubernetes website
(https://kubernetes.io/) :

____
Kubernetes (K8s) is an open-source system for automating deployment, scaling,
and management of containerized applications. It groups containers that make up
an application into logical units for easy management and discovery. Kubernetes
builds upon 15 years of experience of running production workloads at Google,
combined with best-of-breed ideas and practices from the community.
____

this brief description tells a few important facts about kubernetes:

* initiated by google but open-sourced now
* mature and stable product after many years effort
* orchestration tool
* dealing with containers in a higher level

////
> Kubernetes is a portable, extensible open-source platform for managing
> containerized workloads and services, that facilitates both declarative
> configuration and automation. 

> Google open-sourced the Kubernetes project in 2014. Kubernetes builds upon a
> decade and a half of experience that Google has with running production
> workloads at scale, combined with best-of-breed ideas and practices from the
> community.
////

kubernetes was created by a group of engineers in google in 2014, with a design
and development model influenced by Google's internal system named "Borg" .
Kubernetes defines a set of "building objects" (e.g. "pod", "service") which
collectively provides mechanisms that orchestrates containerized applications
across a distributed cluster of nodes, based on system resources (CPU, memory
or other custom metrics).  Kubernetes hides the complexity of managing a group
of containers by providing REST APIs for the required functionalities. 

In simple words, container technologies like docker provides you the capability
of packaging and distributing containerized applications, while an
orchestration system like kubernetes allows you to deploy and manage the
dockers in a relatively higher level and a much easier way.

[TIP]
====
* "Borg" is still being used in google internally today
* in many document kubernetes is frequently abbreviated as "k8s" (K - eight
  characters - S), 
* the "current" (as of the writing of this book) major release is v1.14.
====

== Kubernetes Architecture and components

in a Kubernetes cluster there are two type of nodes, each running a very
well-defined set of processes:

* head node: called "master", or "master node", your head and brian that does
  all thinking and decisions, all of intelligence are located here.
* worker node: called "node", or "union" in old document, your arms and feet
  that conduct the workforce.

=== Kubernetes master

A kubernetes "master node", or "master", is like one's head and brian. in the
cluster master provides the "control plane" that makes all of the global
decisions about the cluster. for example, when you need the cluster to spawn a
container, the master will decide which node to dispatch the task and spawn a
container. this procedure is called "scheduling". master is also responsible
for maintaining the desired state for the cluster. when you give an order "for
this web server make sure there are always 2 containers backing up each
other!", the master will keep monitor the running status and starting up a
container anytime when it sees the number of the web server containers in
"running" status is less than 2. The master is also responsible for other many
jobs. Typically you only need a single master node in the cluster, however, the
master can also be replicated for higher availability (HA) and redundancy.

the master's functions is implemented by a collection of processes running in
node.  The processes in a master node providing the primary features are:
////
and detecting and responding to cluster
events ().
////

* *kube-apiserver*: front-end of the control plane, providing REST APIs
* *kube-scheduler*: do the "scheduling": decide where to place the containers
  depending on system requirement (CPU, memory, harddisk, etc) and other custom
  parameters or constraints (e.g. affinity specification)
* *kube-controller-manager*: the single process implementing most of the
  different type of "controllers", which makes sure that the state of the
  system is what it should be. TODO

  - RC(Replication Controller)
  - RS(ReplicaSet)
  - Deployment
  - StatefulSet
  - DS(DaemonSet)
  - Job
  - Node Controller
  - Service Controller

* *cloud-controller-manager*: TODO
* *etcd*: data store to store the state of the system. 
* *DNS server* for Kubernetes services. 
* *kubelet*: TODO

////
* And sometimes, to be able to manage all of this you have a
  process called a Kubelet. 
* And, of course, you have a container engine, you have Docker. You could have
* something else, but most of the time you have
* Docker. That's what you find on the head node, the brain of Kubernetes.
* Nothing else than four types of processes, an API server, a scheduler, a
* controller manager, and etcd. 
////

One of the most common interface between you and the cluster is a command-line
tool "kubectl". just remember: When you are working with "kubectl" command
later on, you're essentially communicating with the cluster's "master".

=== Kubernetes node

nodes in a cluster are the machines that run the final applications. in
production there can be dozens or hundreds of nodes in one cluster depending on
the designed scales. nodes are the real workforce under the hood provided by a
cluter. All of the containers and workloads are running in nodes. The "nodes"
are controlled by the "master" which you will interact with most of the time.
youâ€™ll rarely need to "bypass" the master and work with nodes directly.

A "node" runs following processes:

* *Kubelet*: the Kubernetes agent process that runs on all the nodes. it
  interacts with master (through kube-apiserver process) and manage the
  containers in local host.
* *kube-proxy*: process that implements "kubernetes service" (will introduce
  later) using linux iptable in the node
* *container-runtime*: local container - mostly 'docker' in today's market,
  holding all of the running "dockerized" applications.

TIP: 
the name "proxy" may sound confusing for kubernetes beginners. it's not really
a "proxy" in current kubernetes architecture. kube-proxy is a system that
manipulates linux IP tables in that node so that the the traffic between the
pods and the nodes will flows correctly.

=== kubernetes cluster lab environment

.PLAN
pick one of the two. or make a new one.

image::https://user-images.githubusercontent.com/2038044/45911926-b5345180-bde7-11e8-82bd-152fffa2774a.png[]

image::https://user-images.githubusercontent.com/2038044/46121001-c7473300-c1df-11e8-90c0-425b94957df1.png[]




=== kubernetes objects 

==== docker vs kubernetes

Now you understand the role of master and nodes in a kubernetes cluster, it is
the time to introduce more concepts in the kubernetes architecture.

as mentioned earlier, technically speaking, kubernetes works in a relatively
higher level than dockers. what does that really mean? Assuming you want to run
multiple containers across multiple machines, you will have a lot of work to
do if you interact with docker directly.  at least the following tasks should
appear in your "worry list":

////
* start the right containers at the right time
* figure out how they can talk to each other
* consider storage configuration
* deal with failed containers or hardware
* consider to add redundancies and high availability to your docker application
////

* Spawning containers across different machines
* Scaling up or down by adding or removing containers when demand changes
* Keeping storage consistent with multiple instances of an application
* Distributing load between the containers
* Launching new containers on different machines if something fails

you will quickly find that doing all of this manually with docker will be
overwhelming. with kubernetes all of these tasks become much easiler.

.PLAN
too much talk already...maybe give a quick example before introducing
objects?

==== kubectl

now let's talk about kubectl - the tool you will need to interact with all
these abstractions/objects.

autocompletion

==== objects

create a yaml file: myweb_rc.yaml

```yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: myweb
spec:
  replicas: 2       #<-----
  selector:
    app: myweb
  template:
    metadata:
      labels:
        app: myweb
    spec:
      containers:
      - name: myweb
        image: kubeguide/tomcat-app:v1
        ports:
        - containerPort: 8080
```

create the objects

```bash
kubectl create -f myweb_rc.yaml
```

list the created objects

```bash

$ kubectl get rc
NAME      DESIRED   CURRENT   READY     AGE
mysql     1         1         0         10s         #<------
myweb     2         2         2         10s

$ kubectl get pod
NAME          READY     STATUS              RESTARTS   AGE
myweb-nv4h8   1/1       ContainerCreating   1          1m       #<---
myweb-vzvk4   1/1       Running             1          1m
```

in the frontend, kubernetes get all these things done via a group of
abstractions, each represented in the form of an "object". with kubernetes you
only needs to think of how to describe your task in the config file, without
the need to worry about how it will be implemented.

"under the hood", kubernetes interact with the Docker engine to coordinate the
scheduling and execution of Docker containers on Kubelets. The Docker engine
itself is responsible for running the actual container image (e.g. by 'docker
build'). 

Higher level concepts such as service-discovery, loadbalancing and
network policies are handled by Kubernetes as well.

TODO: use ftp/tcp/ip as example.

.features and abstractions

features, objects, abstractions, processes, controllers

Kubernetes contains a number of abstractions that represent the state of your
system: deployed containerized applications and workloads, their associated
network and disk resources, and other information about what your cluster is
doing. These abstractions are represented by objects in the Kubernetes API; see
the Kubernetes Objects overview for more details.

The basic Kubernetes objects include:

* Pod
* Service
* Volume
* Namespace

In addition, Kubernetes contains a number of higher-level abstractions called
Controllers. Controllers build upon the basic objects, and provide additional
functionality and convenience features. They include:

* ReplicaSet
* Deployment
* StatefulSet
* DaemonSet
* Job

=== Kubernetes networking

.PLAN: 
*ip-per-pod model
*give brief introduction only

=== a "full picture" - put everything together

.PLAN
a diagram to show most of the components and concepts


== Building Kubernetes POD


=== YAML file for Kubernetes 

=== POD example using YAML files

=== Kubectl tool 

=== Login to container 

=== Intra-POD communications  

=== Inter-POD communications
